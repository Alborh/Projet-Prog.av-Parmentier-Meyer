#include "moteur.h"
#include <stdlib.h>
#include <stdio.h>
#include <SDL/SDL.h>
#include <string.h>


void choix_perso(SDL_Surface* ecran)
{
    SDL_Surface *menuChoix = NULL, *Curseur = NULL;
    SDL_Rect positionMenu, positionCurseur;
    SDL_Event event;

    int continuer = 1;

    menuChoix = SDL_LoadBMP("image/");  //charger l'image du menu de selection du personnage
    Curseur = SDL_LoadBMP("image/");    //charger l'image du curseur de selection


    positionMenu.x = 0;
    positionMenu.y = 0;
    positionCurseur.x = 0; //coordonées à modifier en fonction du menu
    positionCurseur.y = 0;


    while(continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch(event.key.keysym.sym)
            {
            case SDLK_ESCAPE:
                continuer = 0;
                break;
            case SDLK_RIGHT:
                //deplacerCurseurChoix(&positionCurseur,DROITE);
                break;
            case SDLK_LEFT:
                //deplacerCurseurChpix(&positionCurseur,GAUCHE);
                break;
            case SDLK_RETURN:
                break;
            }
            break;
        }

        SDL_BlitSurface(menuChoix, NULL, ecran, &positionMenu);
        SDL_BlitSurface(Curseur, NULL, ecran, &positionCurseur);
        SDL_Flip(ecran);
    }


    SDL_FreeSurface(menuChoix);
    SDL_FreeSurface(Curseur);
}


void deplacerCurseurChoix(SDL_Rect *pos,int direction)
{
    switch (direction)
    {
    case DROITE:
        break;
    case GAUCHE:
        break;
    }
}

int chargerNiveau(struct Tile niveau[][NB_BLOCKS_HAUTEUR])
{
    FILE *fichier = NULL;
    fichier = fopen("niveau/terrain.txt","r");

    rewind(fichier);

    int i=0, j=0;


    for(i = 0; i < NB_BLOCKS_HAUTEUR; i++)
    {
        for(j = 0; j < NB_BLOCKS_LARGEUR; j++)
        {
            niveau[j][i].sprite = fgetc(fichier);
            switch(niveau[j][i].sprite)
            {
            case MUR:
                niveau[j][i].marchable = _MUR;
                break;
            case DALLE:
                niveau[j][i].marchable = _DALLE;
                break;
            case HERBE:
                niveau[j][i].marchable = _HERBE;
                break;
            case ARBRE:
                niveau[j][i].marchable = _ARBRE;
                break;
            case COFFRE:
                niveau[j][i].marchable = _COFFRE;
                break;
            case EAU:
                niveau[j][i].marchable = _EAU;
                break;
            case PONT_H:
                niveau[j][i].marchable = _PONT_H;
                break;
            case PONT_V:
                niveau[j][i].marchable = _PONT_V;
                break;
            case BORD:
                niveau[j][i].marchable = _BORD;
                break;
            case ROUTE:
                niveau[j][i].marchable = _ROUTE;
                break;
            case SPAWN:
                niveau[j][i].marchable = _SPAWN;
                break;
	    case PORTE:
	      niveau[j][i].marchable = _PORTE;
	      break;
	    case VIDE:
	      niveau[j][i].marchable = _VIDE;
	      break;
	    case MONT:
	      niveau[j][i].marchable = _MONT;
	      break;
	    case GOLEM:
	      niveau[j][i].marchable = _GOLEM;
	      break;
            }

        }
        fseek(fichier,2,SEEK_CUR);
    }
    fclose(fichier);
    return 1;
}

void jeu(SDL_Surface* ecran)
{
    SDL_Surface *Joueur[4] = {NULL};
    SDL_Surface *JoueurActuel = NULL;
    SDL_Surface *Terrain [NB_SPRITES]= {NULL};
    SDL_Rect position, positionJoueur, positionFond;
    SDL_Event event;

    int continuer = 1, i = 0, j = 0;
    struct Tile carte[NB_BLOCKS_LARGEUR][NB_BLOCKS_HAUTEUR]={0}; //tableau de données de la carte du niveau



    // chargement des sprites des différents terrains
    Terrain[MUR]=SDL_LoadBMP("image/Mur.dib.bmp"); //sprite du mur
    Terrain[DALLE]=SDL_LoadBMP("image/Dalle.dib.bmp");
    Terrain[HERBE]=SDL_LoadBMP("image/grass.dib.bmp");
    Terrain[ARBRE]=SDL_LoadBMP("image/Arbre.dib.bmp");
    Terrain[COFFRE]=SDL_LoadBMP("image/Coffre.dib.bmp");
    Terrain[EAU]=SDL_LoadBMP("image/eau.dib.bmp");
    Terrain[PONT_H]=SDL_LoadBMP("image/Bridge_H.dib.bmp");
    Terrain[PONT_V]=SDL_LoadBMP("image/Bridge_V.dib.bmp");
    Terrain[BORD]=SDL_LoadBMP("image/Vide.dib.bmp");
    Terrain[ROUTE]=SDL_LoadBMP("image/road.bmp");
    Terrain[SPAWN]=SDL_LoadBMP("image/Spawn.bmp");
    Terrain[PORTE]=SDL_LoadBMP("image/Porte.bmp");
    Terrain[VIDE]=SDL_LoadBMP("image/Vide.dib.bmp");
    Terrain[MONT]=SDL_LoadBMP("image/Montagne.bmp");
    Terrain[GOLEM]=SDL_LoadBMP("image/golem.bmp");
    //chargement des sprites des différentes position du joueur
    Joueur[HAUT] = SDL_LoadBMP("image/Hero.bmp");
    Joueur[BAS] = SDL_LoadBMP("image/Hero.bmp");
    Joueur[GAUCHE] = SDL_LoadBMP("image/Hero.bmp");
    Joueur[DROITE] = SDL_LoadBMP("image/Hero.bmp");
    SDL_SetColorKey(Joueur[HAUT],SDL_SRCCOLORKEY,SDL_MapRGB(Joueur[HAUT]->format,255,0,255));
    SDL_SetColorKey(Joueur[BAS],SDL_SRCCOLORKEY,SDL_MapRGB(Joueur[BAS]->format,255,0,255));
    SDL_SetColorKey(Joueur[GAUCHE],SDL_SRCCOLORKEY,SDL_MapRGB(Joueur[GAUCHE]->format,255,0,255));
    SDL_SetColorKey(Joueur[DROITE],SDL_SRCCOLORKEY,SDL_MapRGB(Joueur[DROITE]->format,255,0,255));



    // preset du joueur dans la position initial
    JoueurActuel = Joueur[BAS];

    //configuration de la position initial des sprites de map
    positionFond.x = 0;
    positionFond.y = 0;

    rechercheSpawn(&positionJoueur, carte);

    if(!chargerNiveau(carte))
        exit(EXIT_FAILURE);

    rechercheSpawn(&positionJoueur, carte);


    SDL_EnableKeyRepeat(100,100);
    while(continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch(event.key.keysym.sym)
            {
            case SDLK_UP:
                JoueurActuel = Joueur[HAUT];
                deplacerJoueur(&positionJoueur, HAUT, carte);
                break;
            case SDLK_DOWN:
                JoueurActuel = Joueur[BAS];
                deplacerJoueur(&positionJoueur,BAS,carte);
                break;
            case SDLK_RIGHT:
                JoueurActuel = Joueur[DROITE];
                deplacerJoueur(&positionJoueur,DROITE,carte);
                break;
            case SDLK_LEFT:
                JoueurActuel = Joueur[GAUCHE];
                deplacerJoueur(&positionJoueur,GAUCHE,carte);
                break;
	    case SDLK_RETURN:
	      i = positionJoueur.y % NB_PIXELS;
	      j = positionJoueur.x % NB_PIXELS;
	      if(carte[j][i]==PORTE)
		{
		  Interieur(ecran, Joueur, JoueurActuel, Terrain);
		}
	      break;
            }
            break;
        }
        SDL_FillRect(ecran,NULL,SDL_MapRGB(ecran->format,255,255,255));

        for(i = 0; i < NB_BLOCKS_HAUTEUR; i++)
        {
            for(j =0; j < NB_BLOCKS_LARGEUR; j++)
            {
                positionFond.x = j*NB_PIXELS;
                positionFond.y = i*NB_PIXELS;
                SDL_BlitSurface(Terrain[carte[j][i].sprite],NULL, ecran, &positionFond);
            }
        }
        position.x = positionJoueur.x*NB_PIXELS;
        position.y = positionJoueur.y*NB_PIXELS;
        SDL_BlitSurface(JoueurActuel, NULL, ecran, &position);

        SDL_Flip(ecran);
    }


    SDL_EnableKeyRepeat(0,0);

    for( i = 0; i < 4; i++)
        SDL_FreeSurface(Joueur[i]);

    for( i = 0; i< NB_SPRITES; i++)
        SDL_FreeSurface(Terrain[i]);

}

void deplacerJoueur(SDL_Rect *pos, int direction, struct Tile carte[][NB_BLOCKS_HAUTEUR])
{
    switch (direction)
    {
    case HAUT:
        if(carte[pos->x][pos->y-1].marchable == 0)
        {
            break;
        }
        else
        {
            pos->y--;
            break;
        }
    case BAS:
        if(carte[pos->x][pos->y+1].marchable == 0)
        {
            break;
        }
        else
        {
            pos->y++;
            break;
        }
    case DROITE:
        if(carte[pos->x+1][pos->y].marchable == 0)
        {
            break;
        }
        else
        {
            pos->x++;
            break;
        }
    case GAUCHE:
        if(carte[pos->x-1][pos->y].marchable == 0)
        {
            break;
        }
        else
        {
            pos->x--;
            break;
        }
    }
}

void rechercheSpawn(SDL_Rect *pos, struct Tile carte[][NB_BLOCKS_HAUTEUR])
{
    int i,j;
    for(i = 0; i < NB_BLOCKS_HAUTEUR; i++)
        {
            for(j =0; j < NB_BLOCKS_LARGEUR; j++)
            {
                if(carte[j][i].sprite == 'S')
                {
                    pos->x = j;
                    pos->y = i;
                }
            }
        }
}

void menu(SDL_Surface* ecran)
{
    SDL_Surface* menuJeu = NULL, *Curseur = NULL;
    SDL_Rect positionMenu, positionCurseur;
    SDL_Event event;

    int continuer =1;

    menuJeu = SDL_LoadBMP("image/game-menu.bmp"); // charger l'image du menu du jeu
    Curseur = SDL_LoadBMP("image/Hand.bmp");      // charger l'image du curseur de selection
    SDL_SetColorKey(Curseur, SDL_SRCCOLORKEY, SDL_MapRGB(Curseur->format,0,255,0));
    //mise en transparence du fond vert du curseur

    positionMenu.x = 0;
    positionMenu.y = 0;
    positionCurseur.x = 300; // coordonnées à modifier en fonction de la configuration du menu
    positionCurseur.y = 450;



    while (continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch(event.key.keysym.sym)
            {
            case SDLK_UP:
                deplacerCurseurMenu(&positionCurseur,HAUT);
                break;
            case SDLK_DOWN:
                deplacerCurseurMenu(&positionCurseur,BAS);
                break;
            case SDLK_RETURN:
                if(positionCurseur.y == 450)
                {
                    jeu(ecran);
                    break;
                }
                if(positionCurseur.y == 500)
                {
                    continuer = 0;
                    break;
                }
            }
            break;
        }
        SDL_BlitSurface(menuJeu, NULL, ecran, &positionMenu);
        SDL_BlitSurface(Curseur, NULL, ecran, &positionCurseur);
        SDL_Flip(ecran);

    }

    SDL_FreeSurface(menuJeu);
    SDL_FreeSurface(Curseur);

}

void deplacerCurseurMenu(SDL_Rect* pos, int direction)
{
    switch(direction) //coordonées à modifier en fonction de la configuration du menu
    {
    case HAUT:
        if(pos->y == 450) //le curseur est en haut du menu
        {
            pos->y = 500; //on descend le curseur en bas du menu
            break;
        }
        else
        {
            pos->y = 450;
            break;
        }
    case BAS:
        if(pos->y == 500) //le curseur est en bas du menu
        {
            pos->y = 450; //on remonte le curseur en haut du menu
            break;
        }
        else
        {
            pos->y = 500;
            break;
        }
    }
}

void Interieur(SDL_Surface *ecran, SDL_Surface *Joueur[],SDL_Surface *JoueurActuel, SDL_Surface *Terrain[])
{
    int continuer = 1;
    SDL_Rect position, positionJoueur, positionFond;
    SDL_Event event;

    int i=0, j=0;

    struct Tile carte[NB_BLOCKS_LARGEUR][NB_BLOCKS_HAUTEUR]={0};

    if(!chargerNiveau(carte, "Interieur"))
        exit(EXIT_FAILURE);


    recherchePorte(&positionJoueur, carte);

    while(continuer)
    {
        SDL_WaitEvent(&event);
        switch(event.type)
        {
        case SDL_QUIT:
            continuer = 0;
            break;
        case SDL_KEYDOWN:
            switch(event.key.keysym.sym)
            {
            case SDLK_UP:
                JoueurActuel = Joueur[HAUT];
                deplacerJoueur(&positionJoueur, HAUT, carte);
                break;
            case SDLK_DOWN:
                JoueurActuel = Joueur[BAS];
                deplacerJoueur(&positionJoueur,BAS,carte);
                break;
            case SDLK_RIGHT:
                JoueurActuel = Joueur[DROITE];
                deplacerJoueur(&positionJoueur,DROITE,carte);
                break;
            case SDLK_LEFT:
                JoueurActuel = Joueur[GAUCHE];
                deplacerJoueur(&positionJoueur,GAUCHE,carte);
                break;
            case SDLK_ESCAPE:

                continuer = 0;
                break;
            case SDLK_RETURN:
                i = positionJoueur.y % NB_PIXELS;
                j = positionJoueur.x % NB_PIXELS;
                if(carte[j][i].sprite == PORTE)
                {
                    continuer = 0;
                }
                break;
            }
            break;
        }
        SDL_FillRect(ecran,NULL,SDL_MapRGB(ecran->format,255,255,255));

        for(i = 0; i < NB_BLOCKS_HAUTEUR; i++)
        {
            for(j =0; j < NB_BLOCKS_LARGEUR; j++)
            {
                positionFond.x = j*NB_PIXELS;
                positionFond.y = i*NB_PIXELS;
                SDL_BlitSurface(Terrain[carte[j][i].sprite],NULL, ecran, &positionFond);
            }
        }
        position.x = positionJoueur.x*NB_PIXELS;
        position.y = positionJoueur.y*NB_PIXELS;
        SDL_BlitSurface(JoueurActuel, NULL, ecran, &position);

        SDL_Flip(ecran);
    }


}

void recherchePorte(SDL_Rect *pos, struct Tile carte[][NB_BLOCKS_HAUTEUR])
{
    int i,j;
    for(i = 0; i < NB_BLOCKS_HAUTEUR; i++)
        {
            for(j =0; j < NB_BLOCKS_LARGEUR; j++)
            {
                if(carte[j][i].sprite == 'P')
                {
                    pos->x = j;
                    pos->y = i;
                }
            }
        }
}

